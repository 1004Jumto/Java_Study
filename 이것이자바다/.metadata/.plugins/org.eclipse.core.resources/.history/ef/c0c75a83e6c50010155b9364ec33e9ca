package ch20.oracle.sec10;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class TransactionExample {

	public static void main(String[] args) {

		//리소스를 열고 닫을 때, 생성한 순서의 역순으로 해제하는 것이 좋음
		Connection conn = null;
		PreparedStatement pstmt = null;
		//어차피 prepareStatement할 때마다 객체는 새로 생성(즉, 하나의 변수에 두 번 할당해도 동일하게 2개 객체 생성)
		//-> 가독성과 유지보수성을 위해 다른 작업을 처리하는 sql구문이면 preparedStatement도 각각 다른 변수명을 지정해주는 것이 좋음. 
		PreparedStatement pstmt2 = null;
		ResultSet rs = null;
		
		try {
			//1. 드라이버 로드 
			Class.forName("oracle.jdbc.OracleDriver");
			
			//2. 커넥션객체 생성 
			conn = DriverManager.getConnection(
					"jdbc:oracle:thin:@localhost:1521/xe",
					"testuser", //사용자명
					"test1234"); //비밀번호
			
			System.out.println("연결 성공");

			//자동커밋기능 끄기-> 트랜잭션 제어를 위해 
			conn.setAutoCommit(false);
			
			//출금
			String sql  = "UPDATE accounts SET balance= balance-? where ano=?";
			
			pstmt = conn.prepareStatement(sql);// 미리준비.

			pstmt.setInt(1, 10000);
			pstmt.setString(2, "111-111-1111");
			
			int result = pstmt.executeUpdate();
			//SQL에서 에러가 발생하지 않아도 업데이트문에 변화가 일어나지 않을 가능성도 존재하니, 이럴 때는 강제로 예외를 발생시켜야 함
			if(result==0)throw new Exception("출금되지 않음.");
			
			//입금
			String sql2  = "UPDATE accounts SET balance= balance+? where ano=?";
			
			pstmt2 = conn.prepareStatement(sql2);

			pstmt2.setInt(1, 10000);
			pstmt.setString(2, "222-222-2222");
//			pstmt2.setString(2, "222-222-2223"); //-> 입금되지 않을 시에 예외를 발생 -> 이거를 캐치쪽에서 잡아서, 트랜잭션 롤백처리 => 트랜잭션 작업 전체 취소
			
			int result2 = pstmt2.executeUpdate(); 
			if(result2==0)throw new Exception("입금되지 않음.");
			
			//커밋 -> 작업 내용 적용
			conn.commit();
			System.out.println("계좌이체성공");
				
		} catch (Exception e) {  //실제 예외 + 강제 예외발생 캐치 
			e.printStackTrace();
			try {
				//계좌이체 실패 시, 롤백으로 작업 취소 
				conn.rollback(); 
			} catch (Exception e1) {}
			System.out.println("계좌이체실패");
			
		}finally {
			try { conn.setAutoCommit(true);  } catch (Exception e) { e.printStackTrace();}
			try { rs.close(); } catch (Exception e) { e.printStackTrace();}
			try { pstmt.close(); } catch (Exception e) { e.printStackTrace();}
			if(conn != null) {
				try {
					//conn 리소스 닫기 전에, 오토커밋 기능 켜기. 
					conn.setAutoCommit(true); 
					conn.close();
					System.out.println("연결 끊기");
				} catch (Exception e2) {
				
				}
			}
		}
		
		
	}

}
